# 图
## 类型
有向图，无向图，加权图
## 术语
图是由顶点和边组成的一种非线形数据结构。相关术语有，顶点，边，路径，路径长度，环，负权环，连通性，顶点的度（入度，出度）

# 算法1： 并查集
如果给你一些顶点，并且告诉你每个顶点的连接关系，如果快速判断其中的两个顶点是否有联通关系呢？
### 两个重要的函数
+ find函数：找到给定顶点的根节点
+ union函数：合并两个顶点，并将他们的根节点保持一致。

###

![image](https://user-images.githubusercontent.com/69283174/144350895-7480526c-1efa-4641-820a-185f3aa29e0e.png)
<!-- https://excalidraw.com/#json=A1I40bn2yWj4I6ap8ETQ5,JcSCqo3xMFtVjCH8gVtD_w -->

## code

```python
class union_find(object):
    def __init__(self,n):
        self.root = list(range(n))
        self.rank = [1] * n   
    def find(self,x): # 路径压缩
        if x == self.root[x]:
            return x
        self.root[x] = self.find(self.root[x]):
        return x
    def union(self,x,y): # 按rank 合并
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.root[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.root[rootX] = rootY
            else:
                self.root[rootY] = rootX
                self.rank[rootX] += 1
    def isconnected(self,x,y):
        return self.find(x) == self.find(y)          
```

# 最小生成树
## 切分定理
切分定理：一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。

## Kruskal 算法
+ 求解加权无向图的最小生成树的一种算法
+ 步骤：（1） 所有边从小到大排序（2） 依次加入到最小生成树中（3）如果形成环则跳过（4）直到选择到N-1条边为止
+ 实现：并查集（检查是否成环），贪心

## Prim 算法
+ 求解加权无向图的最小生成树的一种算法
+ 步骤：（1）create vis = set() (2) 假设当前的顶点是cur, 用小根堆来存储和cur 顶点相连的所有的顶点，如果已访问heappop，（3） 选取堆顶最小的顶点作为下一个顶点（4）直到选到所有的顶点位置
+ 实现：切分定理（找最小的横切边），堆（heapq)

## Kruskal 与 prim 区别
Kruskal： 通过增加边数来扩大最小生成树
Prim: 通过增加顶点来扩大最小生成树 

# 单源最短路径相关算法
「Dijkstra 算法」只能解决加权有向图的权重为非负数的「单源最短路径」问题。「Bellman-Ford 算法」能解决加权有向图中包含权重为负数的「单源最短路径」问题。
 
## Dijkstra 算法

![image](https://user-images.githubusercontent.com/69283174/143677485-a7ebfdf8-d8e7-4eab-b859-5f684713c70c.png)
 
<!-- https://excalidraw.com/#json=uRGDtx0Ft7cggDM0601ut,C7KJTYxR881a_CM8AsO6Aw -->
### 主要思想
以起点 u 为中心，逐步向外扩展并更新其他顶点的「最短路径」。

「Dijkstra 算法」运用了「贪心思想」，它运行的每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」（小根堆）。
 
### 算法限制
「Dijkstra 算法」针对的「图」的类型 必须 满足以下条件：所有边的权重为非负数。


## Bellman-Ford 算法
在前面介绍的「Dijkstra 算法」中，它只能解决没有「负权图」的「单源最短路径」问题。如果遇到有「负权图」，应该怎么解决「单源最短路径」问题呢？那就是这一小节的重点：「Bellman-Ford 算法」。

### 基础定理
定理一：在一个有 N 个顶点的「非负权环图」中，两点之间的最短路径最多经过 N-1 条边。
定理二：「负权环」没有最短路径。

### 主要思想
（1）用动态规划求最短路径 
![image](https://user-images.githubusercontent.com/69283174/143678782-06d63986-24a3-4b0b-b60f-fe8db79f34e7.png)

<!-- https://excalidraw.com/#json=rlgh0fH7vxSuGqbiEN8xG,06YBotIbq9_1va_gntXnqA -->

（2）Bellman-Ford 算法 （优化动态规划的空间）

（3）基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法

 
为了解决上面的缺陷，我们引入了基于「队列」优化的 「Bellman Ford算法」。当然也有人称之为「SPFA 算法」。SPFA 是 Shortest Path Faster Algorithm 的简写。从该小节的题目中，我们可以知道，它是对「Bellman Ford算法」的优化。

「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。此时，我们就可以得到「图」中其他顶点到给定顶点的最短距离了

# 拓扑排序之 Kahn 算法

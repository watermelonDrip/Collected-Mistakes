# 并查集

## code

```python
class union_find(object):
    def __init__(self,n):
        self.root = list(range(n))
        self.rank = [1] * n
    def find(self,x):
        if x == self.root[x]:
            return x
        self.root[x] = self.find(self.root[x]):
        return x
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.root[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.root[rootX] = rootY
            else:
                self.root[rootY] = rootX
                self.rank[rootX] += 1
    def isconnected(self,x,y):
        return self.find(x) == self.find(y)
                
```

# 最小生成树
## 切分定理
切分定理：一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。

## Kruskal 算法
+ 求解加权无向图的最小生成树的一种算法
+ 步骤：（1） 所有边从小到大排序（2） 依次加入到最小生成树中（3）如果形成环则跳过（4）直到选择到N-1条边为止
+ 实现：并查集（检查是否成环），贪心

## Prim 算法
+ 求解加权无向图的最小生成树的一种算法
+ 步骤：（1）create vis = set() (2) 假设当前的顶点是cur, 用小根堆来存储和cur 顶点相连的所有的顶点，如果已访问heappop，（3） 选取堆顶最小的顶点作为下一个顶点（4）直到选到所有的顶点位置
+ 实现：切分定理（找最小的横切边），堆（heapq)

## Kruskal 与 prim 区别
Kruskal： 通过增加边数来扩大最小生成树
Prim: 通过增加顶点来扩大最小生成树 

# 单源最短路径相关算法
「Dijkstra 算法」只能解决加权有向图的权重为非负数的「单源最短路径」问题。「Bellman-Ford 算法」能解决加权有向图中包含权重为负数的「单源最短路径」问题。
 
## Dijkstra 算法

![image](https://user-images.githubusercontent.com/69283174/143677485-a7ebfdf8-d8e7-4eab-b859-5f684713c70c.png)
 
<!-- https://excalidraw.com/#json=uRGDtx0Ft7cggDM0601ut,C7KJTYxR881a_CM8AsO6Aw -->
### 主要思想
以起点 u 为中心，逐步向外扩展并更新其他顶点的「最短路径」。

「Dijkstra 算法」运用了「贪心思想」，它运行的每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」（小根堆）。
 
### 算法限制
「Dijkstra 算法」针对的「图」的类型 必须 满足以下条件：所有边的权重为非负数。


## Bellman-Ford 算法
在前面介绍的「Dijkstra 算法」中，它只能解决没有「负权图」的「单源最短路径」问题。如果遇到有「负权图」，应该怎么解决「单源最短路径」问题呢？那就是这一小节的重点：「Bellman-Ford 算法」。

### 基础定理
定理一：在一个有 N 个顶点的「非负权环图」中，两点之间的最短路径最多经过 N-1 条边。
定理二：「负权环」没有最短路径。

### 主要思想
